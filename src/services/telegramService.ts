import TelegramBot, { CallbackQuery, Message, ParseMode } from 'node-telegram-bot-api';
import config from '../config';
import { LookupResult, UserState, UserStep, UserAction } from '../types';
import { ViolationService } from './violationService';
import { CronService } from './cronService';
import { UserService, CronJobService } from './userService';
import { NotificationService } from './notificationService';

export class TelegramService {
  private bot: TelegramBot;
  private violationService: ViolationService;
  private cronService: CronService;
  private userService: UserService;
  private cronJobService: CronJobService;
  private notificationService: NotificationService;
  private userStates: Record<number, UserState>;

  constructor() {
    if (!config.telegram.token) {
      throw new Error('TELEGRAM_BOT_TOKEN environment variable is required');
    }

    this.bot = new TelegramBot(config.telegram.token, { polling: config.telegram.polling });
    this.violationService = new ViolationService();
    this.userService = new UserService();
    this.cronJobService = new CronJobService();
    this.notificationService = new NotificationService(this.bot);
    this.userStates = {};

    // Initialize CronService (will use config from src/config/index.ts)
    this.cronService = new CronService(this.bot);

    this.setupBotCommands();
    this.setupHandlers();
    this.setupErrorHandlers();
  }

  /**
   * Setup bot commands menu
   */
  private async setupBotCommands(): Promise<void> {
    try {
      await this.bot.setMyCommands([
        { command: 'start', description: 'üöÄ B·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng bot' },
        { command: 'lookup', description: 'üîç Tra c·ª©u vi ph·∫°m giao th√¥ng' },
        { command: 'cron_setup', description: '‚è∞ Thi·∫øt l·∫≠p tra c·ª©u t·ª± ƒë·ªông' },
        { command: 'cron_status', description: 'üìä Xem tr·∫°ng th√°i cron job' },
        { command: 'menu', description: 'üìã Hi·ªÉn th·ªã menu ch√≠nh' },
        { command: 'help', description: '‚ùì H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng' },
      ]);
      console.log('üìã Bot Commands Menu: ‚úÖ Configured');
    } catch (error) {
      console.error('[ERROR] Failed to setup bot commands:', error);
    }
  }

  /**
   * Setup event handlers for the bot
   */
  private setupHandlers(): void {
    // Start command
    this.bot.onText(/\/start/, (msg: Message) => {
      const chatId = msg.chat.id;
      this.showMainMenu(chatId);
    });

    // Help command
    this.bot.onText(/\/help/, (msg: Message) => {
      const chatId = msg.chat.id;
      this.showHelp(chatId);
    });

    // Menu command
    this.bot.onText(/\/menu/, (msg: Message) => {
      const chatId = msg.chat.id;
      this.showMainMenu(chatId);
    });

    // Lookup command
    this.bot.onText(/\/lookup/, (msg: Message) => {
      const chatId = msg.chat.id;
      this.startSearch(chatId);
    });

    // Cron setup command
    this.bot.onText(/\/cron_setup/, async (msg: Message) => {
      const chatId = msg.chat.id;
      await this.startCronSetup(chatId, msg);
    });

    // Cron status command
    this.bot.onText(/\/cron_status/, async (msg: Message) => {
      const chatId = msg.chat.id;
      await this.showCronStatus(chatId);
    });

    // Cron update command
    this.bot.onText(/\/cron_update/, async (msg: Message) => {
      const chatId = msg.chat.id;
      await this.startCronUpdate(chatId);
    });

    // Cron disable command
    this.bot.onText(/\/cron_disable/, async (msg: Message) => {
      const chatId = msg.chat.id;
      await this.disableCronJob(chatId);
    });

    // Handle all messages
    this.bot.on('message', async (msg: Message) => {
      const chatId = msg.chat.id;
      const text = msg.text?.trim();

      // Skip if it's a command
      if (text?.startsWith('/')) return;

      const userState = this.userStates[chatId];

      // If no state, ask user to start
      if (!userState) {
        await this.bot.sendMessage(chatId, 'Vui l√≤ng g√µ /start ƒë·ªÉ b·∫Øt ƒë·∫ßu tra c·ª©u üö¶');
        return;
      }

      await this.handleUserMessage(chatId, text, userState);
    });

    // Handle callback queries from inline keyboard
    this.bot.on('callback_query', async (callbackQuery: CallbackQuery) => {
      await this.handleCallbackQuery(callbackQuery);
    });
  }

  /**
   * Setup error handlers for the bot
   */
  private setupErrorHandlers(): void {
    this.bot.on('polling_error', (error: Error) => {
      if (error.message.includes('409 Conflict')) {
        console.warn('[WARN] Telegram Bot conflict detected. Another instance might be running.');
        console.warn('[WARN] Please ensure only one bot instance is running.');
      } else {
        console.error('[ERROR] Telegram Bot polling error:', error.message);
      }
    });

    this.bot.on('error', (error: Error) => {
      console.error('[ERROR] Telegram Bot error:', error.message);
    });
  }

  /**
   * Show main menu with custom keyboard
   */
  private showMainMenu(chatId: number): void {
    const welcomeMessage = `üöó *Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi Bot Tra C·ª©u Ph·∫°t Ngu·ªôi!*

T√¥i c√≥ th·ªÉ gi√∫p b·∫°n:
‚Ä¢ üîç Tra c·ª©u vi ph·∫°m giao th√¥ng theo bi·ªÉn s·ªë xe
‚Ä¢ üìã Xem h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
‚Ä¢ üÜò Li√™n h·ªá h·ªó tr·ª£

Ch·ªçn m·ªôt t√πy ch·ªçn b√™n d∆∞·ªõi:`;

    const options = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üîç Tra c·ª©u vi ph·∫°m', callback_data: 'start_search' },
            { text: '‚ùì H∆∞·ªõng d·∫´n', callback_data: 'show_help' },
          ],
          [
            { text: 'üìã Menu ch√≠nh', callback_data: 'show_menu' },
            { text: 'üÜò H·ªó tr·ª£', callback_data: 'show_support' },
          ],
        ],
      },
      parse_mode: 'Markdown' as ParseMode,
    };

    this.bot.sendMessage(chatId, welcomeMessage, options);
  }

  /**
   * Show help information
   */
  private showHelp(chatId: number): void {
    const helpMessage = `‚ùì *H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng Bot Tra C·ª©u Ph·∫°t Ngu·ªôi!*

*C√°c l·ªánh c√≥ s·∫µn:*
/start - üöÄ B·∫Øt ƒë·∫ßu s·ª≠ d·ª•ng bot
/help - ‚ùì Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n n√†y
/menu - üìã Hi·ªÉn th·ªã menu ch√≠nh
/lookup - üîç B·∫Øt ƒë·∫ßu tra c·ª©u vi ph·∫°m

*C√°ch s·ª≠ d·ª•ng:*
1Ô∏è‚É£ Nh·∫•n "üîç Tra c·ª©u vi ph·∫°m" ho·∫∑c g√µ /lookup
2Ô∏è‚É£ Ch·ªçn lo·∫°i xe (√¥ t√¥, xe m√°y, xe ƒë·∫°p ƒëi·ªán)
3Ô∏è‚É£ Nh·∫≠p bi·ªÉn s·ªë xe (v√≠ d·ª•: 51K01234)
4Ô∏è‚É£ Ch·ªù k·∫øt qu·∫£ tra c·ª©u

*L∆∞u √Ω:*
‚Ä¢ Bi·ªÉn s·ªë ph·∫£i ƒë√∫ng ƒë·ªãnh d·∫°ng
‚Ä¢ K·∫øt qu·∫£ c√≥ th·ªÉ m·∫•t v√†i gi√¢y ƒë·ªÉ t·∫£i
‚Ä¢ B·∫°n c√≥ th·ªÉ c·∫≠p nh·∫≠t k·∫øt qu·∫£ b·∫•t k·ª≥ l√∫c n√†o

*H·ªó tr·ª£:*
N·∫øu g·∫∑p v·∫•n ƒë·ªÅ, vui l√≤ng li√™n h·ªá qua /menu`;

    const options = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üîç B·∫Øt ƒë·∫ßu tra c·ª©u', callback_data: 'start_search' },
            { text: 'üìã Menu ch√≠nh', callback_data: 'show_menu' },
          ],
        ],
      },
      parse_mode: 'Markdown' as ParseMode,
    };

    this.bot.sendMessage(chatId, helpMessage, options);
  }

  /**
   * Start lookup process
   */
  private startSearch(chatId: number): void {
    this.userStates[chatId] = { step: UserStep.ASK_VEHICLE_TYPE };

    const options = {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'üöó Xe √¥ t√¥',
              callback_data: 'vehicle_type_1',
            },
          ],
          [
            {
              text: 'üèçÔ∏è Xe m√°y',
              callback_data: 'vehicle_type_2',
            },
          ],
          [
            {
              text: 'üö¥‚Äç‚ôÄÔ∏è Xe ƒë·∫°p ƒëi·ªán',
              callback_data: 'vehicle_type_3',
            },
          ],
        ],
      },
    };

    this.bot.sendMessage(chatId, 'üîª Ch·ªçn lo·∫°i xe c·ªßa b·∫°n:', options);
  }

  /**
   * Handle messages from users
   */
  private async handleUserMessage(
    chatId: number,
    text: string | undefined,
    userState: UserState,
  ): Promise<void> {
    try {
      // Handle regular violation lookup
      if (
        userState.step === UserStep.ASK_PLATE &&
        userState.action !== UserAction.CRON_SETUP &&
        userState.action !== UserAction.CRON_UPDATE
      ) {
        userState.plate = text;
        userState.step = UserStep.FETCHING;

        this.bot.sendMessage(chatId, '‚è≥ ƒêang tra c·ª©u vi ph·∫°m, vui l√≤ng ch·ªù...');

        // Lookup violations
        const result = await this.violationService.lookupByPlate(
          userState.plate!,
          userState.vehicleType!,
        );

        await this.sendViolationResults(chatId, result, userState);
      }

      // Handle cron job setup plate input
      if (
        userState.step === UserStep.CRON_ASK_PLATE &&
        (userState.action === UserAction.CRON_SETUP || userState.action === UserAction.CRON_UPDATE)
      ) {
        userState.plate = text;

        // Validate plate
        const validation = this.cronJobService.validateCronJobData({
          userId: 0, // Will be set later
          plate: text!,
          vehicleType: userState.vehicleType!,
        });

        if (!validation.valid) {
          await this.bot.sendMessage(
            chatId,
            `‚ùå ${validation.error}\n\nüìù Vui l√≤ng nh·∫≠p l·∫°i bi·ªÉn s·ªë xe:`,
          );
          return;
        }

        // Get user
        const userResult = await this.userService.getUserByChatId(chatId);
        if (!userResult.success) {
          await this.bot.sendMessage(chatId, '‚ùå L·ªói: Kh√¥ng t√¨m th·∫•y th√¥ng tin user.');
          delete this.userStates[chatId];
          return;
        }

        const userId = userResult.data!.id;

        // Setup or update cron job
        this.bot.sendMessage(chatId, '‚è≥ ƒêang thi·∫øt l·∫≠p tra c·ª©u t·ª± ƒë·ªông...');

        const result = await this.cronJobService.setupCronJob({
          userId,
          plate: text!,
          vehicleType: userState.vehicleType!,
        });

        if (result.success) {
          await this.notificationService.sendCronJobSetupConfirmation(
            chatId,
            text!,
            userState.vehicleType!,
          );
        } else {
          await this.bot.sendMessage(
            chatId,
            `‚ùå C√≥ l·ªói x·∫£y ra khi thi·∫øt l·∫≠p tra c·ª©u t·ª± ƒë·ªông: ${result.error}`,
          );
        }

        // Clear user state
        delete this.userStates[chatId];
      }
    } catch (error) {
      console.error('[ERROR] Telegram Service:', error);

      // Handle unexpected errors (not from service result)
      const errorMessage = error instanceof Error ? error.message : String(error);

      if (
        userState.action === UserAction.CRON_SETUP ||
        userState.action === UserAction.CRON_UPDATE
      ) {
        await this.bot.sendMessage(chatId, `‚ùå C√≥ l·ªói x·∫£y ra: ${errorMessage}`);
        delete this.userStates[chatId];
      } else {
        await this.handleLookupError(chatId, errorMessage, userState);
      }
    }
  }

  /**
   * Handle callback queries from inline keyboard
   */
  private async handleCallbackQuery(callbackQuery: CallbackQuery): Promise<void> {
    const chatId = callbackQuery.message?.chat.id;
    if (!chatId || !callbackQuery.data) return;

    // Remove the inline keyboard
    const messageId = callbackQuery.message?.message_id;
    if (messageId) {
      await this.bot.editMessageReplyMarkup(
        { inline_keyboard: [] },
        {
          chat_id: chatId,
          message_id: messageId,
        },
      );
    }

    if (callbackQuery.data === 'new_search' || callbackQuery.data === 'start_search') {
      // Start new lookup
      this.userStates[chatId] = { step: UserStep.ASK_VEHICLE_TYPE };

      // Answer the callback query
      await this.bot.answerCallbackQuery(callbackQuery.id);

      const options = {
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: 'üöó Xe √¥ t√¥',
                callback_data: 'vehicle_type_1',
              },
            ],
            [
              {
                text: 'üèçÔ∏è Xe m√°y',
                callback_data: 'vehicle_type_2',
              },
            ],
            [
              {
                text: 'üö¥‚Äç‚ôÄÔ∏è Xe ƒë·∫°p ƒëi·ªán',
                callback_data: 'vehicle_type_3',
              },
            ],
          ],
        },
      };

      await this.bot.sendMessage(chatId, 'üîª Ch·ªçn lo·∫°i xe c·ªßa b·∫°n:', options);
    } else if (callbackQuery.data === 'show_menu') {
      // Show main menu
      await this.bot.answerCallbackQuery(callbackQuery.id);
      this.showMainMenu(chatId);
    } else if (callbackQuery.data === 'show_help') {
      // Show help
      await this.bot.answerCallbackQuery(callbackQuery.id);
      this.showHelp(chatId);
    } else if (callbackQuery.data === 'show_support') {
      // Show support
      await this.bot.answerCallbackQuery(callbackQuery.id);
      await this.bot.sendMessage(
        chatId,
        'üÜò *H·ªó tr·ª£ k·ªπ thu·∫≠t*\n\n' +
          'N·∫øu b·∫°n g·∫∑p v·∫•n ƒë·ªÅ khi s·ª≠ d·ª•ng bot, vui l√≤ng:\n' +
          '‚Ä¢ Ki·ªÉm tra l·∫°i bi·ªÉn s·ªë xe\n' +
          '‚Ä¢ Th·ª≠ l·∫°i sau v√†i ph√∫t\n' +
          '‚Ä¢ S·ª≠ d·ª•ng l·ªánh /menu ƒë·ªÉ quay l·∫°i menu ch√≠nh\n\n' +
          'Bot ƒë∆∞·ª£c ph√°t tri·ªÉn ƒë·ªÉ h·ªó tr·ª£ tra c·ª©u vi ph·∫°m giao th√¥ng m·ªôt c√°ch nhanh ch√≥ng v√† ch√≠nh x√°c.',
        { parse_mode: 'Markdown' },
      );
    } else if (callbackQuery.data === 'change_vehicle_type') {
      // Handle change vehicle type
      await this.bot.answerCallbackQuery(callbackQuery.id);

      // Reset to vehicle type selection step but keep any existing plate number
      const userState = this.userStates[chatId];
      if (userState) {
        userState.step = UserStep.ASK_VEHICLE_TYPE;
        // Keep the plate number if user has already entered it
        const existingPlate = userState.plate;

        const options = {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: 'üöó Xe √¥ t√¥',
                  callback_data: 'vehicle_type_1',
                },
              ],
              [
                {
                  text: 'üèçÔ∏è Xe m√°y',
                  callback_data: 'vehicle_type_2',
                },
              ],
              [
                {
                  text: 'üö¥‚Äç‚ôÄÔ∏è Xe ƒë·∫°p ƒëi·ªán',
                  callback_data: 'vehicle_type_3',
                },
              ],
            ],
          },
        };

        let message = 'üîª Ch·ªçn lo·∫°i xe c·ªßa b·∫°n:';
        if (existingPlate) {
          message += `\n\nüìù Bi·ªÉn s·ªë ƒë√£ nh·∫≠p: ${existingPlate}`;
        }

        await this.bot.sendMessage(chatId, message, options);
      }
    } else if (callbackQuery.data.startsWith('cron_vehicle_type_')) {
      // Handle cron vehicle type selection
      const vehicleType = callbackQuery.data.split('_')[3];
      const userState = this.userStates[chatId];

      if (userState) {
        userState.vehicleType = vehicleType;
        userState.step = UserStep.CRON_ASK_PLATE;

        // Answer the callback query
        await this.bot.answerCallbackQuery(callbackQuery.id);

        // Get vehicle type display name
        const vehicleTypeNames = {
          '1': 'üöó Xe √¥ t√¥',
          '2': 'üèçÔ∏è Xe m√°y',
          '3': 'üö¥‚Äç‚ôÄÔ∏è Xe ƒë·∫°p ƒëi·ªán',
        };
        const selectedVehicleType =
          vehicleTypeNames[vehicleType as keyof typeof vehicleTypeNames] || 'Ph∆∞∆°ng ti·ªán';

        await this.bot.sendMessage(
          chatId,
          `üìã Lo·∫°i xe ƒë√£ ch·ªçn: ${selectedVehicleType}\n\n` +
            `üî¢ Nh·∫≠p bi·ªÉn s·ªë xe c·ªßa b·∫°n (v√≠ d·ª•: 51K01234):`,
        );
      }
    } else if (callbackQuery.data === 'cancel_cron_setup') {
      // Cancel cron setup
      await this.bot.answerCallbackQuery(callbackQuery.id);
      delete this.userStates[chatId];
      await this.bot.sendMessage(chatId, '‚ùå ƒê√£ h·ªßy thi·∫øt l·∫≠p tra c·ª©u t·ª± ƒë·ªông.');
    } else if (callbackQuery.data === 'start_cron_setup') {
      // Start cron setup from callback
      await this.bot.answerCallbackQuery(callbackQuery.id);

      if (callbackQuery.message?.from) {
        const tempMsg: Message = {
          message_id: callbackQuery.message.message_id,
          date: callbackQuery.message.date,
          chat: callbackQuery.message.chat,
          from: callbackQuery.message.from,
        };
        await this.startCronSetup(chatId, tempMsg);
      }
    } else if (callbackQuery.data.startsWith('vehicle_type_')) {
      // Handle vehicle type selection
      const vehicleType = callbackQuery.data.split('_')[2];
      const userState = this.userStates[chatId];

      if (userState) {
        userState.vehicleType = vehicleType;
        userState.step = UserStep.ASK_PLATE;

        // Answer the callback query
        await this.bot.answerCallbackQuery(callbackQuery.id);

        // Get vehicle type display name
        const vehicleTypeNames = {
          '1': 'üöó Xe √¥ t√¥',
          '2': 'üèçÔ∏è Xe m√°y',
          '3': 'üö¥‚Äç‚ôÄÔ∏è Xe ƒë·∫°p ƒëi·ªán',
        };
        const selectedVehicleType =
          vehicleTypeNames[vehicleType as keyof typeof vehicleTypeNames] || 'Ph∆∞∆°ng ti·ªán';

        const options = {
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: `üîÑ Thay ƒë·ªïi lo·∫°i xe`,
                  callback_data: 'change_vehicle_type',
                },
              ],
            ],
          },
        };

        let message = `üìã Lo·∫°i xe ƒë√£ ch·ªçn: ${selectedVehicleType}\n\nüî¢ Nh·∫≠p s·ªë bi·ªÉn s·ªë xe c·ªßa b·∫°n (v√≠ d·ª•: 51K01234):`;

        // If user already has a plate number, show it and ask if they want to keep it
        if (userState.plate) {
          message += `\n\nüìù Bi·ªÉn s·ªë hi·ªán t·∫°i: ${userState.plate}`;
          message += `\n\nB·∫°n c√≥ th·ªÉ gi·ªØ nguy√™n bi·ªÉn s·ªë n√†y ho·∫∑c nh·∫≠p bi·ªÉn s·ªë m·ªõi.`;
        }

        await this.bot.sendMessage(chatId, message, options);
      }
    } else if (callbackQuery.data.startsWith('refresh_')) {
      // Format: refresh_vehicleType_plate
      const [, vehicleType, plate] = callbackQuery.data.split('_');

      await this.bot.sendMessage(chatId, '‚è≥ ƒêang c·∫≠p nh·∫≠t th√¥ng tin m·ªõi nh·∫•t, vui l√≤ng ch·ªù...');

      try {
        const result = await this.violationService.lookupByPlate(plate, vehicleType);
        await this.sendViolationResults(chatId, result, {
          step: UserStep.FETCHING,
          vehicleType,
          plate,
        });
      } catch (error) {
        console.error('[ERROR] Telegram Service:', error);

        // Handle unexpected errors (not from service result)
        const errorMessage = error instanceof Error ? error.message : String(error);
        await this.handleLookupError(chatId, errorMessage, {
          step: UserStep.FETCHING,
          vehicleType,
          plate,
        });
      }
    } else if (callbackQuery.data === 'retry_search') {
      // Handle retry lookup - restart the lookup process
      await this.bot.answerCallbackQuery(callbackQuery.id);

      // Get the current user state to retry with same parameters
      const userState = this.userStates[chatId];
      if (userState && userState.plate && userState.vehicleType) {
        // Retry with same parameters
        userState.step = UserStep.FETCHING;

        await this.bot.sendMessage(chatId, '‚è≥ ƒêang th·ª≠ l·∫°i tra c·ª©u, vui l√≤ng ch·ªù...');

        try {
          const result = await this.violationService.lookupByPlate(
            userState.plate,
            userState.vehicleType,
          );
          await this.sendViolationResults(chatId, result, userState);
        } catch (error) {
          console.error('[ERROR] Telegram Service:', error);

          // Handle unexpected errors (not from service result)
          const errorMessage = error instanceof Error ? error.message : String(error);
          await this.handleLookupError(chatId, errorMessage, userState);
        }
      } else {
        // No previous state, start new lookup
        this.startSearch(chatId);
      }
    }
  }

  /**
   * Send violation results to user
   */
  private async sendViolationResults(
    chatId: number,
    result: LookupResult,
    userState: UserState,
  ): Promise<void> {
    // Lookup if there's an error in the result
    if (result.status === 'error') {
      await this.handleLookupError(chatId, result.message || 'Unknown error occurred', userState);
      return;
    }

    const violations = result.data?.violations || [];

    if (!violations || violations.length === 0) {
      // No violations found
      const options = {
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: 'üîÑ C·∫≠p nh·∫≠t k·∫øt qu·∫£ m·ªõi',
                callback_data: `refresh_${userState.vehicleType}_${userState.plate}`,
              },
              { text: 'üîé Tra c·ª©u bi·ªÉn s·ªë kh√°c', callback_data: 'new_search' },
            ],
            [{ text: 'üìã Menu ch√≠nh', callback_data: 'show_menu' }],
          ],
        },
      };
      await this.bot.sendMessage(
        chatId,
        '‚úÖ Kh√¥ng t√¨m th·∫•y vi ph·∫°m n√†o cho ph∆∞∆°ng ti·ªán n√†y.',
        options,
      );
      return;
    }

    // Send each violation
    for (const violation of violations) {
      let message = `üö® Vi ph·∫°m giao th√¥ng l√∫c ${violation.violationTime}\n\n`;
      message += `üìç ƒê·ªãa ƒëi·ªÉm vi ph·∫°m: ${violation.location}\n\n`;
      message += `‚ùå Lo·∫°i vi ph·∫°m: ${violation.violation}\n\n`;
      message += `üí∞ S·ªë ti·ªÅn ph·∫°t: ${violation.fine || 'Ch∆∞a c√≥ th√¥ng tin'}\n\n`;
      message += `üìå Tr·∫°ng th√°i: ${violation.status || 'Ch∆∞a x·ª≠ l√Ω'}\n\n`;
      message += `üè¢ ƒê∆°n v·ªã x·ª≠ l√Ω: ${violation.resolutionDepartment || 'Ch∆∞a c√≥ th√¥ng tin'}\n\n`;

      if (violation.resolutionAddress) {
        message += `üìÆ ƒê·ªãa ch·ªâ n·ªôp ph·∫°t: ${violation.resolutionAddress}\n\n`;
      }

      if (violation.resolutionPhone) {
        message += `üìû S·ªë ƒëi·ªán tho·∫°i li√™n h·ªá: ${violation.resolutionPhone}`;
      }

      await this.bot.sendMessage(chatId, message);
    }

    // Add options after showing all violations
    const options = {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'üîÑ C·∫≠p nh·∫≠t k·∫øt qu·∫£ m·ªõi',
              callback_data: `refresh_${userState.vehicleType}_${userState.plate}`,
            },
            { text: 'üîé Tra c·ª©u bi·ªÉn s·ªë kh√°c', callback_data: 'new_search' },
          ],
          [{ text: 'üìã Menu ch√≠nh', callback_data: 'show_menu' }],
        ],
      },
    };
    await this.bot.sendMessage(chatId, 'C√°c t√πy ch·ªçn kh√°c:', options);

    // Reset state
    delete this.userStates[chatId];
  }

  /**
   * Handle lookup errors with specific error messages
   * @param chatId - Chat ID to send message to
   * @param errorMessage - Error message from lookup
   * @param userState - Current user state
   */
  private async handleLookupError(
    chatId: number,
    errorMessage: string,
    userState: UserState,
  ): Promise<void> {
    // Lookup if this is a captcha-related error first
    if (this.isCaptchaError(errorMessage)) {
      await this.handleCaptchaError(chatId, errorMessage, userState);
      // Reset state after showing captcha error
      delete this.userStates[chatId];
      return;
    }

    let friendlyMessage = '';

    if (errorMessage.includes('404')) {
      friendlyMessage =
        `üîí *L·ªói k·∫øt n·ªëi*\n\n` +
        `Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn h·ªá th·ªëng tra c·ª©u. ƒêi·ªÅu n√†y c√≥ th·ªÉ do:\n` +
        `‚Ä¢ H·ªá th·ªëng ƒëang b·∫£o tr√¨\n` +
        `‚Ä¢ Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n\n` +
        `‚Ä¢ Website c√≥ th·ªÉ ƒë√£ thay ƒë·ªïi\n\n` +
        `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i sau v√†i ph√∫t`;
    } else if (errorMessage.includes('403')) {
      friendlyMessage =
        `üö´ *Truy c·∫≠p b·ªã t·ª´ ch·ªëi*\n\n` +
        `H·ªá th·ªëng ƒë√£ t·ª´ ch·ªëi y√™u c·∫ßu tra c·ª©u. ƒêi·ªÅu n√†y c√≥ th·ªÉ do:\n` +
        `‚Ä¢ Qu√° nhi·ªÅu y√™u c·∫ßu trong th·ªùi gian ng·∫Øn\n` +
        `‚Ä¢ H·ªá th·ªëng ƒëang b·∫£o v·ªá ch·ªëng spam\n\n` +
        `üí° *G·ª£i √Ω:* Ch·ªù v√†i ph√∫t r·ªìi th·ª≠ l·∫°i`;
    } else if (errorMessage.includes('Timeout')) {
      friendlyMessage =
        `‚è∞ *H·∫øt th·ªùi gian ch·ªù*\n\n` +
        `H·ªá th·ªëng ph·∫£n h·ªìi qu√° ch·∫≠m. ƒêi·ªÅu n√†y c√≥ th·ªÉ do:\n` +
        `‚Ä¢ K·∫øt n·ªëi m·∫°ng kh√¥ng ·ªïn ƒë·ªãnh\n` +
        `‚Ä¢ H·ªá th·ªëng ƒëang qu√° t·∫£i\n\n` +
        `üí° *G·ª£i √Ω:* Ki·ªÉm tra k·∫øt n·ªëi m·∫°ng v√† th·ª≠ l·∫°i`;
    } else if (errorMessage.includes('Server error')) {
      friendlyMessage =
        `üîß *L·ªói h·ªá th·ªëng*\n\n` +
        `H·ªá th·ªëng tra c·ª©u ƒëang g·∫∑p s·ª± c·ªë k·ªπ thu·∫≠t. ƒêi·ªÅu n√†y c√≥ th·ªÉ do:\n` +
        `‚Ä¢ L·ªói server t·∫°m th·ªùi\n` +
        `‚Ä¢ H·ªá th·ªëng ƒëang ƒë∆∞·ª£c c·∫≠p nh·∫≠t\n\n` +
        `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i sau 10-15 ph√∫t`;
    } else if (errorMessage.includes('Captcha validation failed')) {
      friendlyMessage =
        `üîê *L·ªói x√°c th·ª±c Captcha*\n\n` +
        `Kh√¥ng th·ªÉ x√°c th·ª±c m√£ captcha. ƒêi·ªÅu n√†y c√≥ th·ªÉ do:\n` +
        `‚Ä¢ M√£ captcha kh√¥ng ch√≠nh x√°c\n` +
        `‚Ä¢ M√£ captcha ƒë√£ h·∫øt h·∫°n\n` +
        `‚Ä¢ H·ªá th·ªëng captcha g·∫∑p s·ª± c·ªë\n\n` +
        `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i ƒë·ªÉ nh·∫≠n m√£ captcha m·ªõi`;
    } else {
      friendlyMessage =
        `‚ùå *L·ªói kh√¥ng x√°c ƒë·ªãnh*\n\n` +
        `ƒê√£ x·∫£y ra l·ªói trong qu√° tr√¨nh tra c·ª©u:\n` +
        `\`${errorMessage}\`\n\n` +
        `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i sau v√†i ph√∫t`;
    }

    // Create retry options
    const options = {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'üîÑ Th·ª≠ l·∫°i',
              callback_data: `refresh_${userState.vehicleType}_${userState.plate}`,
            },
            { text: 'üîé Tra c·ª©u kh√°c', callback_data: 'new_search' },
          ],
          [{ text: 'üìã Menu ch√≠nh', callback_data: 'show_menu' }],
        ],
      },
      parse_mode: 'Markdown' as const,
    };

    await this.bot.sendMessage(chatId, friendlyMessage, options);

    // Reset state after showing error
    delete this.userStates[chatId];
  }

  /**
   * Lookup if an error is captcha-related
   * @param errorMessage - Error message to lookup
   * @returns {boolean} True if error is captcha-related
   */
  private isCaptchaError(errorMessage: string): boolean {
    const captchaKeywords = [
      'Captcha validation failed',
      'Tesseract OCR failed',
      'Autocaptcha error',
      'Captcha solving failed',
      'AUTOCAPTCHA_KEY not set',
      'Failed to extract captcha text',
      'Low confidence score',
      'OCR failed to extract text',
    ];

    return captchaKeywords.some((keyword) =>
      errorMessage.toLowerCase().includes(keyword.toLowerCase()),
    );
  }

  /**
   * Handle captcha-related errors with friendly Vietnamese messages
   * @param chatId - Chat ID to send message to
   * @param errorMessage - Original error message
   * @param userState - Current user state (optional)
   */
  private async handleCaptchaError(
    chatId: number,
    errorMessage: string,
    userState?: UserState,
  ): Promise<void> {
    let friendlyMessage = '';

    if (errorMessage.includes('Captcha validation failed')) {
      if (errorMessage.includes('404')) {
        friendlyMessage =
          `üîí *L·ªói x√°c th·ª±c Captcha*\n\n` +
          `H·ªá th·ªëng kh√¥ng th·ªÉ x√°c th·ª±c m√£ captcha. ƒêi·ªÅu n√†y c√≥ th·ªÉ do:\n` +
          `‚Ä¢ M√£ captcha ƒë√£ h·∫øt h·∫°n\n` +
          `‚Ä¢ Phi√™n l√†m vi·ªác ƒë√£ h·∫øt h·∫°n\n` +
          `‚Ä¢ Website c√≥ th·ªÉ ƒë√£ thay ƒë·ªïi\n\n` +
          `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i sau v√†i ph√∫t ho·∫∑c s·ª≠ d·ª•ng n√∫t "üîÑ C·∫≠p nh·∫≠t k·∫øt qu·∫£ m·ªõi"`;
      } else if (errorMessage.includes('403')) {
        friendlyMessage =
          `üö´ *Truy c·∫≠p b·ªã t·ª´ ch·ªëi*\n\n` +
          `H·ªá th·ªëng ƒë√£ t·ª´ ch·ªëi y√™u c·∫ßu c·ªßa b·∫°n. C√≥ th·ªÉ do:\n` +
          `‚Ä¢ Qu√° nhi·ªÅu y√™u c·∫ßu trong th·ªùi gian ng·∫Øn\n` +
          `‚Ä¢ H·ªá th·ªëng ƒëang b·∫£o tr√¨\n\n` +
          `üí° *G·ª£i √Ω:* Ch·ªù v√†i ph√∫t r·ªìi th·ª≠ l·∫°i`;
      } else if (
        errorMessage.includes('500') ||
        errorMessage.includes('502') ||
        errorMessage.includes('503')
      ) {
        friendlyMessage =
          `üîß *L·ªói m√°y ch·ªß*\n\n` +
          `M√°y ch·ªß ƒëang g·∫∑p s·ª± c·ªë t·∫°m th·ªùi. Vui l√≤ng th·ª≠ l·∫°i sau.\n\n` +
          `üí° *G·ª£i √Ω:* Ch·ªù 5-10 ph√∫t r·ªìi th·ª≠ l·∫°i`;
      } else if (errorMessage.includes('Timeout')) {
        friendlyMessage =
          `‚è∞ *H·∫øt th·ªùi gian ch·ªù*\n\n` +
          `M√°y ch·ªß ph·∫£n h·ªìi qu√° ch·∫≠m. Vui l√≤ng th·ª≠ l·∫°i.\n\n` +
          `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i ngay b√¢y gi·ªù`;
      } else {
        friendlyMessage =
          `‚ùå *L·ªói x√°c th·ª±c Captcha*\n\n` +
          `Kh√¥ng th·ªÉ x√°c th·ª±c m√£ captcha. Vui l√≤ng th·ª≠ l·∫°i.\n\n` +
          `üí° *G·ª£i √Ω:* S·ª≠ d·ª•ng n√∫t "üîÑ C·∫≠p nh·∫≠t k·∫øt qu·∫£ m·ªõi"`;
      }
    } else if (
      errorMessage.includes('Tesseract OCR failed') ||
      errorMessage.includes('OCR failed to extract text')
    ) {
      friendlyMessage =
        `üîç *L·ªói nh·∫≠n d·∫°ng Captcha*\n\n` +
        `H·ªá th·ªëng kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c m√£ captcha t·ª´ h√¨nh ·∫£nh.\n\n` +
        `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i ƒë·ªÉ l·∫•y m√£ captcha m·ªõi`;
    } else if (errorMessage.includes('Autocaptcha error')) {
      friendlyMessage =
        `ü§ñ *L·ªói d·ªãch v·ª• Captcha*\n\n` +
        `D·ªãch v·ª• gi·∫£i captcha t·ª± ƒë·ªông g·∫∑p s·ª± c·ªë.\n\n` +
        `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i sau v√†i ph√∫t`;
    } else if (errorMessage.includes('AUTOCAPTCHA_KEY not set')) {
      friendlyMessage =
        `üîë *C·∫•u h√¨nh thi·∫øu*\n\n` +
        `D·ªãch v·ª• gi·∫£i captcha ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh ƒë·∫ßy ƒë·ªß.\n\n` +
        `üí° *G·ª£i √Ω:* Li√™n h·ªá qu·∫£n tr·ªã vi√™n`;
    } else if (errorMessage.includes('Low confidence score')) {
      friendlyMessage =
        `‚ö†Ô∏è *ƒê·ªô tin c·∫≠y th·∫•p*\n\n` +
        `M√£ captcha ƒë∆∞·ª£c nh·∫≠n d·∫°ng v·ªõi ƒë·ªô tin c·∫≠y th·∫•p.\n\n` +
        `üí° *G·ª£i √Ω:* Th·ª≠ l·∫°i ƒë·ªÉ l·∫•y m√£ captcha r√µ r√†ng h∆°n`;
    } else {
      friendlyMessage =
        `‚ùå *L·ªói gi·∫£i Captcha*\n\n` +
        `Kh√¥ng th·ªÉ gi·∫£i m√£ captcha. Vui l√≤ng th·ª≠ l·∫°i.\n\n` +
        `üí° *G·ª£i √Ω:* S·ª≠ d·ª•ng n√∫t "üîÑ C·∫≠p nh·∫≠t k·∫øt qu·∫£ m·ªõi"`;
    }

    // Add retry options based on user state
    let retryCallbackData = 'retry_search';
    if (userState?.plate && userState?.vehicleType) {
      retryCallbackData = `refresh_${userState.vehicleType}_${userState.plate}`;
    }

    const options = {
      reply_markup: {
        inline_keyboard: [
          [
            { text: 'üîÑ Th·ª≠ l·∫°i ngay', callback_data: retryCallbackData },
            { text: 'üîé Tra c·ª©u kh√°c', callback_data: 'new_search' },
          ],
          [{ text: 'üìã Menu ch√≠nh', callback_data: 'show_menu' }],
        ],
      },
      parse_mode: 'Markdown' as ParseMode,
    };

    await this.bot.sendMessage(chatId, friendlyMessage, options);
  }

  /**
   * Start cron job setup
   */
  private async startCronSetup(chatId: number, msg: Message): Promise<void> {
    try {
      // Register or get user
      const userResult = await this.userService.registerOrGetUser({
        chatId,
        username: msg.from?.username,
        firstName: msg.from?.first_name,
        lastName: msg.from?.last_name,
      });

      if (!userResult.success) {
        await this.bot.sendMessage(chatId, '‚ùå L·ªói: Kh√¥ng th·ªÉ ƒëƒÉng k√Ω user. Vui l√≤ng th·ª≠ l·∫°i.');
        return;
      }

      // Initialize user state for cron setup
      this.userStates[chatId] = {
        step: UserStep.CRON_ASK_VEHICLE_TYPE,
        action: UserAction.CRON_SETUP,
      };

      const options = {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üöó Xe √¥ t√¥', callback_data: 'cron_vehicle_type_1' }],
            [{ text: 'üèçÔ∏è Xe m√°y', callback_data: 'cron_vehicle_type_2' }],
            [{ text: 'üö¥‚Äç‚ôÄÔ∏è Xe ƒë·∫°p ƒëi·ªán', callback_data: 'cron_vehicle_type_3' }],
            [{ text: '‚ùå H·ªßy', callback_data: 'cancel_cron_setup' }],
          ],
        },
      };

      // Format cron schedule to Vietnamese description
      const formatCronSchedule = (cronExpression: string): string => {
        const parts = cronExpression.split(' ');
        if (parts.length !== 5) return cronExpression;

        const [minute, hour, day, month, weekday] = parts;

        // Handle interval patterns
        if (minute.includes('*/')) {
          const interval = minute.split('/')[1];
          return `m·ªói ${interval} ph√∫t`;
        }

        if (hour.includes('*/')) {
          const interval = hour.split('/')[1];
          const minuteNum = minute === '*' ? '00' : minute.padStart(2, '0');
          return `m·ªói ${interval} gi·ªù (ph√∫t th·ª© ${minuteNum})`;
        }

        const hourNum = hour === '*' ? '00' : hour.padStart(2, '0');
        const minuteNum = minute === '*' ? '00' : minute.padStart(2, '0');
        const time = `${hourNum}:${minuteNum}`;

        if (day === '*' && month === '*' && weekday === '*') {
          return `m·ªói ng√†y l√∫c ${time}`;
        }

        return `l√∫c ${time}`;
      };

      const scheduleDescription = formatCronSchedule(config.cron.schedule);

      await this.bot.sendMessage(
        chatId,
        '‚è∞ *THI·∫æT L·∫¨P TRA C·ª®U T·ª∞ ƒê·ªòNG*\n\n' +
          `Bot s·∫Ω t·ª± ƒë·ªông tra c·ª©u vi ph·∫°m cho ph∆∞∆°ng ti·ªán c·ªßa b·∫°n ${scheduleDescription}.\n\n` +
          'üîª Ch·ªçn lo·∫°i xe c·ªßa b·∫°n:',
        { ...options, parse_mode: 'Markdown' },
      );
    } catch (error) {
      console.error('[ERROR] Start cron setup:', error);
      await this.bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.');
    }
  }

  /**
   * Show cron job status
   */
  private async showCronStatus(chatId: number): Promise<void> {
    try {
      const status = await this.cronJobService.getCronJobStatus(chatId);

      if (!status.hasCronJob) {
        const message =
          'üìã *TR·∫†NG TH√ÅI TRA C·ª®U T·ª∞ ƒê·ªòNG*\n\n' +
          '‚ùå B·∫°n ch∆∞a thi·∫øt l·∫≠p tra c·ª©u t·ª± ƒë·ªông.\n\n' +
          'üí° *ƒê·ªÉ thi·∫øt l·∫≠p:*\n' +
          '‚Ä¢ G√µ /cron_setup ƒë·ªÉ b·∫Øt ƒë·∫ßu';

        const options = {
          reply_markup: {
            inline_keyboard: [[{ text: '‚è∞ Thi·∫øt l·∫≠p ngay', callback_data: 'start_cron_setup' }]],
          },
          parse_mode: 'Markdown' as ParseMode,
        };

        await this.bot.sendMessage(chatId, message, options);
        return;
      }

      await this.notificationService.sendCronJobStatus(
        chatId,
        status.hasCronJob,
        status.cronJob
          ? {
              plate: status.cronJob.plate,
              vehicleType: status.cronJob.vehicleType,
              lastRun: status.cronJob.lastRun?.toISOString(),
              nextRun: status.cronJob.nextRun?.toISOString(),
            }
          : undefined,
        status.isActive,
      );
    } catch (error) {
      console.error('[ERROR] Show cron status:', error);
      await this.bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.');
    }
  }

  /**
   * Start cron job update
   */
  private async startCronUpdate(chatId: number): Promise<void> {
    try {
      // Check if user has cron job
      const status = await this.cronJobService.getCronJobStatus(chatId);

      if (!status.hasCronJob) {
        await this.bot.sendMessage(
          chatId,
          '‚ùå B·∫°n ch∆∞a c√≥ tra c·ª©u t·ª± ƒë·ªông n√†o.\n\nüí° S·ª≠ d·ª•ng /cron_setup ƒë·ªÉ thi·∫øt l·∫≠p.',
        );
        return;
      }

      // Initialize user state for cron update
      this.userStates[chatId] = {
        step: UserStep.CRON_ASK_VEHICLE_TYPE,
        action: UserAction.CRON_UPDATE,
      };

      const options = {
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üöó Xe √¥ t√¥', callback_data: 'cron_vehicle_type_1' }],
            [{ text: 'üèçÔ∏è Xe m√°y', callback_data: 'cron_vehicle_type_2' }],
            [{ text: 'üö¥‚Äç‚ôÄÔ∏è Xe ƒë·∫°p ƒëi·ªán', callback_data: 'cron_vehicle_type_3' }],
            [{ text: '‚ùå H·ªßy', callback_data: 'cancel_cron_setup' }],
          ],
        },
      };

      await this.bot.sendMessage(
        chatId,
        'üîÑ *C·∫¨P NH·∫¨T PH∆Ø∆†NG TI·ªÜN*\n\n' +
          `üìã Ph∆∞∆°ng ti·ªán hi·ªán t·∫°i: ${status.cronJob?.plate} (Lo·∫°i ${status.cronJob?.vehicleType})\n\n` +
          'üîª Ch·ªçn lo·∫°i xe m·ªõi:',
        { ...options, parse_mode: 'Markdown' },
      );
    } catch (error) {
      console.error('[ERROR] Start cron update:', error);
      await this.bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.');
    }
  }

  /**
   * Disable cron job
   */
  private async disableCronJob(chatId: number): Promise<void> {
    try {
      // Get user
      const userResult = await this.userService.getUserByChatId(chatId);
      if (!userResult.success) {
        await this.bot.sendMessage(chatId, '‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin user.');
        return;
      }

      const userId = userResult.data!.id;

      // Disable cron job
      const result = await this.cronJobService.disableCronJob(userId);

      if (result.success) {
        await this.notificationService.sendCronJobDisabledConfirmation(chatId, result.data!.plate);
      } else {
        await this.bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi t·∫Øt tra c·ª©u t·ª± ƒë·ªông.');
      }
    } catch (error) {
      console.error('[ERROR] Disable cron job:', error);
      await this.bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.');
    }
  }

  /**
   * Start the bot
   */
  start(): void {
    console.log('ü§ñ Telegram Bot started successfully!');

    // Start CronService
    this.cronService.start();
  }

  /**
   * Stop the bot
   */
  stop(): void {
    console.log('üõë Stopping Telegram Bot...');

    // Stop CronService
    this.cronService.stop();

    this.bot.stopPolling();
    console.log('‚úÖ Telegram Bot stopped successfully!');
  }

  /**
   * Get bot instance for external use
   */
  getBot(): TelegramBot {
    return this.bot;
  }

  /**
   * Get CronService instance for external use
   */
  getCronService(): CronService {
    return this.cronService;
  }
}
